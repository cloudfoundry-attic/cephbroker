// This file was generated by counterfeiter
package cephfakes

import (
	"sync"

	"github.com/cloudfoundry-incubator/cephbroker/cephbrokerlocal"
	"github.com/cloudfoundry-incubator/cephbroker/model"
	"github.com/pivotal-golang/lager"
)

type FakeController struct {
	GetCatalogStub        func(logger lager.Logger) (model.Catalog, error)
	getCatalogMutex       sync.RWMutex
	getCatalogArgsForCall []struct {
		logger lager.Logger
	}
	getCatalogReturns struct {
		result1 model.Catalog
		result2 error
	}
	CreateServiceInstanceStub        func(logger lager.Logger, service_instance_id string, properties interface{}) (model.CreateServiceInstanceResponse, error)
	createServiceInstanceMutex       sync.RWMutex
	createServiceInstanceArgsForCall []struct {
		logger              lager.Logger
		service_instance_id string
		properties          interface{}
	}
	createServiceInstanceReturns struct {
		result1 model.CreateServiceInstanceResponse
		result2 error
	}
	ServiceInstanceExistsStub        func(logger lager.Logger, service_instance_id string) bool
	serviceInstanceExistsMutex       sync.RWMutex
	serviceInstanceExistsArgsForCall []struct {
		logger              lager.Logger
		service_instance_id string
	}
	serviceInstanceExistsReturns struct {
		result1 bool
	}
	ServiceInstancePropertiesMatchStub        func(logger lager.Logger, service_instance_id string, properties interface{}) bool
	serviceInstancePropertiesMatchMutex       sync.RWMutex
	serviceInstancePropertiesMatchArgsForCall []struct {
		logger              lager.Logger
		service_instance_id string
		properties          interface{}
	}
	serviceInstancePropertiesMatchReturns struct {
		result1 bool
	}
}

func (fake *FakeController) GetCatalog(logger lager.Logger) (model.Catalog, error) {
	fake.getCatalogMutex.Lock()
	fake.getCatalogArgsForCall = append(fake.getCatalogArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.getCatalogMutex.Unlock()
	if fake.GetCatalogStub != nil {
		return fake.GetCatalogStub(logger)
	} else {
		return fake.getCatalogReturns.result1, fake.getCatalogReturns.result2
	}
}

func (fake *FakeController) GetCatalogCallCount() int {
	fake.getCatalogMutex.RLock()
	defer fake.getCatalogMutex.RUnlock()
	return len(fake.getCatalogArgsForCall)
}

func (fake *FakeController) GetCatalogArgsForCall(i int) lager.Logger {
	fake.getCatalogMutex.RLock()
	defer fake.getCatalogMutex.RUnlock()
	return fake.getCatalogArgsForCall[i].logger
}

func (fake *FakeController) GetCatalogReturns(result1 model.Catalog, result2 error) {
	fake.GetCatalogStub = nil
	fake.getCatalogReturns = struct {
		result1 model.Catalog
		result2 error
	}{result1, result2}
}

func (fake *FakeController) CreateServiceInstance(logger lager.Logger, service_instance_id string, properties interface{}) (model.CreateServiceInstanceResponse, error) {
	fake.createServiceInstanceMutex.Lock()
	fake.createServiceInstanceArgsForCall = append(fake.createServiceInstanceArgsForCall, struct {
		logger              lager.Logger
		service_instance_id string
		properties          interface{}
	}{logger, service_instance_id, properties})
	fake.createServiceInstanceMutex.Unlock()
	if fake.CreateServiceInstanceStub != nil {
		return fake.CreateServiceInstanceStub(logger, service_instance_id, properties)
	} else {
		return fake.createServiceInstanceReturns.result1, fake.createServiceInstanceReturns.result2
	}
}

func (fake *FakeController) CreateServiceInstanceCallCount() int {
	fake.createServiceInstanceMutex.RLock()
	defer fake.createServiceInstanceMutex.RUnlock()
	return len(fake.createServiceInstanceArgsForCall)
}

func (fake *FakeController) CreateServiceInstanceArgsForCall(i int) (lager.Logger, string, interface{}) {
	fake.createServiceInstanceMutex.RLock()
	defer fake.createServiceInstanceMutex.RUnlock()
	return fake.createServiceInstanceArgsForCall[i].logger, fake.createServiceInstanceArgsForCall[i].service_instance_id, fake.createServiceInstanceArgsForCall[i].properties
}

func (fake *FakeController) CreateServiceInstanceReturns(result1 model.CreateServiceInstanceResponse, result2 error) {
	fake.CreateServiceInstanceStub = nil
	fake.createServiceInstanceReturns = struct {
		result1 model.CreateServiceInstanceResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeController) ServiceInstanceExists(logger lager.Logger, service_instance_id string) bool {
	fake.serviceInstanceExistsMutex.Lock()
	fake.serviceInstanceExistsArgsForCall = append(fake.serviceInstanceExistsArgsForCall, struct {
		logger              lager.Logger
		service_instance_id string
	}{logger, service_instance_id})
	fake.serviceInstanceExistsMutex.Unlock()
	if fake.ServiceInstanceExistsStub != nil {
		return fake.ServiceInstanceExistsStub(logger, service_instance_id)
	} else {
		return fake.serviceInstanceExistsReturns.result1
	}
}

func (fake *FakeController) ServiceInstanceExistsCallCount() int {
	fake.serviceInstanceExistsMutex.RLock()
	defer fake.serviceInstanceExistsMutex.RUnlock()
	return len(fake.serviceInstanceExistsArgsForCall)
}

func (fake *FakeController) ServiceInstanceExistsArgsForCall(i int) (lager.Logger, string) {
	fake.serviceInstanceExistsMutex.RLock()
	defer fake.serviceInstanceExistsMutex.RUnlock()
	return fake.serviceInstanceExistsArgsForCall[i].logger, fake.serviceInstanceExistsArgsForCall[i].service_instance_id
}

func (fake *FakeController) ServiceInstanceExistsReturns(result1 bool) {
	fake.ServiceInstanceExistsStub = nil
	fake.serviceInstanceExistsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeController) ServiceInstancePropertiesMatch(logger lager.Logger, service_instance_id string, properties interface{}) bool {
	fake.serviceInstancePropertiesMatchMutex.Lock()
	fake.serviceInstancePropertiesMatchArgsForCall = append(fake.serviceInstancePropertiesMatchArgsForCall, struct {
		logger              lager.Logger
		service_instance_id string
		properties          interface{}
	}{logger, service_instance_id, properties})
	fake.serviceInstancePropertiesMatchMutex.Unlock()
	if fake.ServiceInstancePropertiesMatchStub != nil {
		return fake.ServiceInstancePropertiesMatchStub(logger, service_instance_id, properties)
	} else {
		return fake.serviceInstancePropertiesMatchReturns.result1
	}
}

func (fake *FakeController) ServiceInstancePropertiesMatchCallCount() int {
	fake.serviceInstancePropertiesMatchMutex.RLock()
	defer fake.serviceInstancePropertiesMatchMutex.RUnlock()
	return len(fake.serviceInstancePropertiesMatchArgsForCall)
}

func (fake *FakeController) ServiceInstancePropertiesMatchArgsForCall(i int) (lager.Logger, string, interface{}) {
	fake.serviceInstancePropertiesMatchMutex.RLock()
	defer fake.serviceInstancePropertiesMatchMutex.RUnlock()
	return fake.serviceInstancePropertiesMatchArgsForCall[i].logger, fake.serviceInstancePropertiesMatchArgsForCall[i].service_instance_id, fake.serviceInstancePropertiesMatchArgsForCall[i].properties
}

func (fake *FakeController) ServiceInstancePropertiesMatchReturns(result1 bool) {
	fake.ServiceInstancePropertiesMatchStub = nil
	fake.serviceInstancePropertiesMatchReturns = struct {
		result1 bool
	}{result1}
}

var _ cephbrokerlocal.Controller = new(FakeController)
